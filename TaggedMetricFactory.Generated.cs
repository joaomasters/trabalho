//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;

namespace StackExchange.Metrics
{
    using StackExchange.Metrics.Infrastructure;
    using StackExchange.Metrics.Metrics;

    partial class MetricSource
    {
        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1}" /> with the specified tags/aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1> AddAggregateGauge<TTag1>(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1) 
            => Add<AggregateGauge<TTag1>, AggregateGauge>(new AggregateGauge<TTag1>(aggregators, name, unit, description, tag1, Options));

        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1}" /> with the specified tags, using <see cref="GaugeAggregator.Default" /> aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1> AddAggregateGauge<TTag1>(string name, string unit, string description, in MetricTag<TTag1> tag1) 
            => Add<AggregateGauge<TTag1>, AggregateGauge>(new AggregateGauge<TTag1>(GaugeAggregator.Default, name, unit, description, tag1, Options));

        /// <summary>
        /// Creates a new <see cref="Counter{TTag1}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual Counter<TTag1> AddCounter<TTag1>(string name, string unit, string description, in MetricTag<TTag1> tag1) 
            => Add<Counter<TTag1>, Counter>(new Counter<TTag1>(name, unit, description, tag1, Options));

        /// <summary>
        /// Creates a new <see cref="CumulativeCounter{TTag1}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual CumulativeCounter<TTag1> AddCumulativeCounter<TTag1>(string name, string unit, string description, in MetricTag<TTag1> tag1) 
            => Add<CumulativeCounter<TTag1>, CumulativeCounter>(new CumulativeCounter<TTag1>(name, unit, description, tag1, Options));

        /// <summary>
        /// Creates a new <see cref="EventGauge{TTag1}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual EventGauge<TTag1> AddEventGauge<TTag1>(string name, string unit, string description, in MetricTag<TTag1> tag1) 
            => Add<EventGauge<TTag1>, EventGauge>(new EventGauge<TTag1>(name, unit, description, tag1, Options));

        /// <summary>
        /// Creates a new <see cref="SamplingGauge{TTag1}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SamplingGauge<TTag1> AddSamplingGauge<TTag1>(string name, string unit, string description, in MetricTag<TTag1> tag1) 
            => Add<SamplingGauge<TTag1>, SamplingGauge>(new SamplingGauge<TTag1>(name, unit, description, tag1, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotCounter{TTag1}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotCounter<TTag1> AddSnapshotCounter<TTag1>(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1) 
            => Add<SnapshotCounter<TTag1>, SnapshotCounter>(new SnapshotCounter<TTag1>(getCountFunc, name, unit, description, tag1, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotGauge{TTag1}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotGauge<TTag1> AddSnapshotGauge<TTag1>(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1) 
            => Add<SnapshotGauge<TTag1>, SnapshotGauge>(new SnapshotGauge<TTag1>(getValueFunc, name, unit, description, tag1, Options));
    }
    
    namespace Infrastructure
    {
        /// <summary>
        /// A set of time series which share the same metric name, but have different, strongly-typed tags.
        /// </summary>
        public abstract class TaggedMetricFactory<TMetric, TTag1> : TaggedMetricFactory<TMetric> where TMetric : MetricBase
        {
            private readonly TaggedMetricDictionary<TTag1> _metrics = new TaggedMetricDictionary<TTag1>();

            /// <summary>
            /// Initializes the base class
            /// </summary>
            protected TaggedMetricFactory(string name, string unit, string description, MetricSourceOptions options, in MetricTag<TTag1> tag1) : base(name, unit, description, options)
            {
                Tag1 = TransformAndValidate(tag1);
            }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag1> Tag1 { get; }

            /// <summary>
            /// Gets or adds a new metric for the specific permutation of tag values.
            /// </summary>
            protected TMetric GetOrAdd(TTag1 tag1) => _metrics.GetOrAdd(tag1, (key, factory) => factory.Create(key), this);

            /// <inheritdoc />
            protected override IEnumerable<TMetric> GetMetrics() => _metrics.Values;

            private TMetric Create(TTag1 tag1)
            {
                var tags = ImmutableDictionary.CreateBuilder<string, string>();
                tags[Tag1.Name] = TransformAndValidate(Tag1.Name, tag1);
                return Create(tags.ToImmutable());
            }
        }
    }

    namespace Metrics
    {
        using StackExchange.Metrics.Handlers;
        using StackExchange.Metrics.Infrastructure;

        /// <summary>
        /// A general-purpose manually incremented long-integer counter.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#counter
        /// </summary>
        public sealed class Counter<TTag1> : TaggedMetricFactory<Counter, TTag1>
        {
            internal Counter(string name, string unit, string description, in MetricTag<TTag1> tag1, MetricSourceOptions options) : base(name, unit, description, options, tag1) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by <paramref name="amount" />.
            /// </summary>
            public void Increment(TTag1 tag1, long amount = 1) => GetOrAdd(tag1).Increment(amount);

            /// <inheritdoc />
            protected override Counter Create(ImmutableDictionary<string, string> tags) => new Counter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// A counter that is recorded using the deltas everytime it is incremented . Used for very low-volume events.
        /// </summary>
        /// <remarks>
        /// When using a Bosun endpoint <see cref="BosunMetricHandler.EnableExternalCounters"/> must be true
        /// to be reported. You'll also need to make sure your infrastructure is setup with external counters enabled. This currently requires using tsdbrelay.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#externalcounter
        /// </remarks>
        public sealed class CumulativeCounter<TTag1> : TaggedMetricFactory<CumulativeCounter, TTag1>
        {
            internal CumulativeCounter(string name, string unit, string description, in MetricTag<TTag1> tag1, MetricSourceOptions options) : base(name, unit, description, options, tag1) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by 1.
            /// </summary>
            public void Increment(TTag1 tag1) => GetOrAdd(tag1).Increment();

            /// <inheritdoc />
            protected override CumulativeCounter Create(ImmutableDictionary<string, string> tags) => new CumulativeCounter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Every data point results in a <see cref="MetricReading"/>. Good for low-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#eventgauge
        /// </summary>
        public sealed class EventGauge<TTag1> : TaggedMetricFactory<EventGauge, TTag1>
        {
            internal EventGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, MetricSourceOptions options) : base(name, unit, description, options, tag1) { }

            /// <summary>
            /// Records a data point which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, double value) => Record(tag1, value, DateTime.UtcNow);

            /// <summary>
            /// Records a data point with an explicit timestamp which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, double value, DateTime time) => GetOrAdd(tag1).Record(value, time);

            /// <inheritdoc />
            protected override EventGauge Create(ImmutableDictionary<string, string> tags) => new EventGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Record as often as you want, but only the last value recorded before the reporting interval is sent to an endpoint (it samples the current value).
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#samplinggauge
        /// </summary>
        public sealed class SamplingGauge<TTag1> : TaggedMetricFactory<SamplingGauge, TTag1>
        {
            internal SamplingGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, MetricSourceOptions options) : base(name, unit, description, options, tag1) { }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, double value) => GetOrAdd(tag1).Record(value);

            /// <inheritdoc />
            protected override SamplingGauge Create(ImmutableDictionary<string, string> tags) => new SamplingGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Calls a user-provided Func&lt;long?&gt; to get the current counter value each time metrics are going to be posted to a metrics handler.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotcounter
        /// </summary>
        public sealed class SnapshotCounter<TTag1> : TaggedMetricFactory<SnapshotCounter, TTag1>
        {
            private readonly Func<long?> _getCountFunc;

            internal SnapshotCounter(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, MetricSourceOptions options) : base(name, unit, description, options, tag1)
            {
                if (getCountFunc == null)
                {
                    throw new ArgumentNullException(nameof(getCountFunc));
                }

                _getCountFunc = getCountFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotCounter" /> for the specified tags.
            /// </summary>
            public SnapshotCounter Get(TTag1 tag1) => GetOrAdd(tag1);

            /// <inheritdoc />
            protected override SnapshotCounter Create(ImmutableDictionary<string, string> tags) => new SnapshotCounter(_getCountFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Similar to a SnapshotCounter, it calls a user provided Func&lt;double?&gt; to get the current gauge value each time metrics are going to be posted to
        /// a metrics handler. See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotgauge
        /// </summary>
        public sealed class SnapshotGauge<TTag1> : TaggedMetricFactory<SnapshotGauge, TTag1>
        {
            private readonly Func<double?> _getValueFunc;

            internal SnapshotGauge(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, MetricSourceOptions options) : base(name, unit, description, options, tag1)
            {
                if (getValueFunc == null)
                {
                    throw new ArgumentNullException(nameof(getValueFunc));
                }

                _getValueFunc = getValueFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotGauge" /> for the specified tags.
            /// </summary>
            public SnapshotGauge Get(TTag1 tag1) => GetOrAdd(tag1);

            /// <inheritdoc />
            protected override SnapshotGauge Create(ImmutableDictionary<string, string> tags) => new SnapshotGauge(_getValueFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Aggregates data points (min, max, avg, median, etc) before sending them to a handler. Good for recording high-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#aggregategauge
        /// </summary>
        public sealed class AggregateGauge<TTag1> : TaggedMetricFactory<AggregateGauge, TTag1>
        {
            private readonly IEnumerable<GaugeAggregator> _aggregators;

            internal AggregateGauge(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, MetricSourceOptions options) : base(name, unit, description, options, tag1)
            {
                _aggregators = aggregators;
            }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, double value) => GetOrAdd(tag1).Record(value);

            /// <inheritdoc />
            protected override AggregateGauge Create(ImmutableDictionary<string, string> tags) => new AggregateGauge(_aggregators, Name, Unit, Description, Options, tags);
        }
    }
    partial class MetricSource
    {
        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1, TTag2}" /> with the specified tags/aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1, TTag2> AddAggregateGauge<TTag1, TTag2>(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) 
            => Add<AggregateGauge<TTag1, TTag2>, AggregateGauge>(new AggregateGauge<TTag1, TTag2>(aggregators, name, unit, description, tag1, tag2, Options));

        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1, TTag2}" /> with the specified tags, using <see cref="GaugeAggregator.Default" /> aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1, TTag2> AddAggregateGauge<TTag1, TTag2>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) 
            => Add<AggregateGauge<TTag1, TTag2>, AggregateGauge>(new AggregateGauge<TTag1, TTag2>(GaugeAggregator.Default, name, unit, description, tag1, tag2, Options));

        /// <summary>
        /// Creates a new <see cref="Counter{TTag1, TTag2}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual Counter<TTag1, TTag2> AddCounter<TTag1, TTag2>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) 
            => Add<Counter<TTag1, TTag2>, Counter>(new Counter<TTag1, TTag2>(name, unit, description, tag1, tag2, Options));

        /// <summary>
        /// Creates a new <see cref="CumulativeCounter{TTag1, TTag2}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual CumulativeCounter<TTag1, TTag2> AddCumulativeCounter<TTag1, TTag2>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) 
            => Add<CumulativeCounter<TTag1, TTag2>, CumulativeCounter>(new CumulativeCounter<TTag1, TTag2>(name, unit, description, tag1, tag2, Options));

        /// <summary>
        /// Creates a new <see cref="EventGauge{TTag1, TTag2}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual EventGauge<TTag1, TTag2> AddEventGauge<TTag1, TTag2>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) 
            => Add<EventGauge<TTag1, TTag2>, EventGauge>(new EventGauge<TTag1, TTag2>(name, unit, description, tag1, tag2, Options));

        /// <summary>
        /// Creates a new <see cref="SamplingGauge{TTag1, TTag2}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SamplingGauge<TTag1, TTag2> AddSamplingGauge<TTag1, TTag2>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) 
            => Add<SamplingGauge<TTag1, TTag2>, SamplingGauge>(new SamplingGauge<TTag1, TTag2>(name, unit, description, tag1, tag2, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotCounter{TTag1, TTag2}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotCounter<TTag1, TTag2> AddSnapshotCounter<TTag1, TTag2>(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) 
            => Add<SnapshotCounter<TTag1, TTag2>, SnapshotCounter>(new SnapshotCounter<TTag1, TTag2>(getCountFunc, name, unit, description, tag1, tag2, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotGauge{TTag1, TTag2}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotGauge<TTag1, TTag2> AddSnapshotGauge<TTag1, TTag2>(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) 
            => Add<SnapshotGauge<TTag1, TTag2>, SnapshotGauge>(new SnapshotGauge<TTag1, TTag2>(getValueFunc, name, unit, description, tag1, tag2, Options));
    }
    
    namespace Infrastructure
    {
        /// <summary>
        /// A set of time series which share the same metric name, but have different, strongly-typed tags.
        /// </summary>
        public abstract class TaggedMetricFactory<TMetric, TTag1, TTag2> : TaggedMetricFactory<TMetric> where TMetric : MetricBase
        {
            private readonly TaggedMetricDictionary<(TTag1 Tag1, TTag2 Tag2)> _metrics = new TaggedMetricDictionary<(TTag1 Tag1, TTag2 Tag2)>();

            /// <summary>
            /// Initializes the base class
            /// </summary>
            protected TaggedMetricFactory(string name, string unit, string description, MetricSourceOptions options, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2) : base(name, unit, description, options)
            {
                Tag1 = TransformAndValidate(tag1);
                Tag2 = TransformAndValidate(tag2);
            }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag1> Tag1 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag2> Tag2 { get; }

            /// <summary>
            /// Gets or adds a new metric for the specific permutation of tag values.
            /// </summary>
            protected TMetric GetOrAdd(TTag1 tag1, TTag2 tag2) => _metrics.GetOrAdd((tag1, tag2), (key, factory) => factory.Create(key.Tag1, key.Tag2), this);

            /// <inheritdoc />
            protected override IEnumerable<TMetric> GetMetrics() => _metrics.Values;

            private TMetric Create(TTag1 tag1, TTag2 tag2)
            {
                var tags = ImmutableDictionary.CreateBuilder<string, string>();
                tags[Tag1.Name] = TransformAndValidate(Tag1.Name, tag1);
                tags[Tag2.Name] = TransformAndValidate(Tag2.Name, tag2);
                return Create(tags.ToImmutable());
            }
        }
    }

    namespace Metrics
    {
        using StackExchange.Metrics.Handlers;
        using StackExchange.Metrics.Infrastructure;

        /// <summary>
        /// A general-purpose manually incremented long-integer counter.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#counter
        /// </summary>
        public sealed class Counter<TTag1, TTag2> : TaggedMetricFactory<Counter, TTag1, TTag2>
        {
            internal Counter(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by <paramref name="amount" />.
            /// </summary>
            public void Increment(TTag1 tag1, TTag2 tag2, long amount = 1) => GetOrAdd(tag1, tag2).Increment(amount);

            /// <inheritdoc />
            protected override Counter Create(ImmutableDictionary<string, string> tags) => new Counter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// A counter that is recorded using the deltas everytime it is incremented . Used for very low-volume events.
        /// </summary>
        /// <remarks>
        /// When using a Bosun endpoint <see cref="BosunMetricHandler.EnableExternalCounters"/> must be true
        /// to be reported. You'll also need to make sure your infrastructure is setup with external counters enabled. This currently requires using tsdbrelay.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#externalcounter
        /// </remarks>
        public sealed class CumulativeCounter<TTag1, TTag2> : TaggedMetricFactory<CumulativeCounter, TTag1, TTag2>
        {
            internal CumulativeCounter(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by 1.
            /// </summary>
            public void Increment(TTag1 tag1, TTag2 tag2) => GetOrAdd(tag1, tag2).Increment();

            /// <inheritdoc />
            protected override CumulativeCounter Create(ImmutableDictionary<string, string> tags) => new CumulativeCounter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Every data point results in a <see cref="MetricReading"/>. Good for low-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#eventgauge
        /// </summary>
        public sealed class EventGauge<TTag1, TTag2> : TaggedMetricFactory<EventGauge, TTag1, TTag2>
        {
            internal EventGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2) { }

            /// <summary>
            /// Records a data point which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, double value) => Record(tag1, tag2, value, DateTime.UtcNow);

            /// <summary>
            /// Records a data point with an explicit timestamp which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, double value, DateTime time) => GetOrAdd(tag1, tag2).Record(value, time);

            /// <inheritdoc />
            protected override EventGauge Create(ImmutableDictionary<string, string> tags) => new EventGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Record as often as you want, but only the last value recorded before the reporting interval is sent to an endpoint (it samples the current value).
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#samplinggauge
        /// </summary>
        public sealed class SamplingGauge<TTag1, TTag2> : TaggedMetricFactory<SamplingGauge, TTag1, TTag2>
        {
            internal SamplingGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2) { }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, double value) => GetOrAdd(tag1, tag2).Record(value);

            /// <inheritdoc />
            protected override SamplingGauge Create(ImmutableDictionary<string, string> tags) => new SamplingGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Calls a user-provided Func&lt;long?&gt; to get the current counter value each time metrics are going to be posted to a metrics handler.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotcounter
        /// </summary>
        public sealed class SnapshotCounter<TTag1, TTag2> : TaggedMetricFactory<SnapshotCounter, TTag1, TTag2>
        {
            private readonly Func<long?> _getCountFunc;

            internal SnapshotCounter(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2)
            {
                if (getCountFunc == null)
                {
                    throw new ArgumentNullException(nameof(getCountFunc));
                }

                _getCountFunc = getCountFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotCounter" /> for the specified tags.
            /// </summary>
            public SnapshotCounter Get(TTag1 tag1, TTag2 tag2) => GetOrAdd(tag1, tag2);

            /// <inheritdoc />
            protected override SnapshotCounter Create(ImmutableDictionary<string, string> tags) => new SnapshotCounter(_getCountFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Similar to a SnapshotCounter, it calls a user provided Func&lt;double?&gt; to get the current gauge value each time metrics are going to be posted to
        /// a metrics handler. See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotgauge
        /// </summary>
        public sealed class SnapshotGauge<TTag1, TTag2> : TaggedMetricFactory<SnapshotGauge, TTag1, TTag2>
        {
            private readonly Func<double?> _getValueFunc;

            internal SnapshotGauge(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2)
            {
                if (getValueFunc == null)
                {
                    throw new ArgumentNullException(nameof(getValueFunc));
                }

                _getValueFunc = getValueFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotGauge" /> for the specified tags.
            /// </summary>
            public SnapshotGauge Get(TTag1 tag1, TTag2 tag2) => GetOrAdd(tag1, tag2);

            /// <inheritdoc />
            protected override SnapshotGauge Create(ImmutableDictionary<string, string> tags) => new SnapshotGauge(_getValueFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Aggregates data points (min, max, avg, median, etc) before sending them to a handler. Good for recording high-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#aggregategauge
        /// </summary>
        public sealed class AggregateGauge<TTag1, TTag2> : TaggedMetricFactory<AggregateGauge, TTag1, TTag2>
        {
            private readonly IEnumerable<GaugeAggregator> _aggregators;

            internal AggregateGauge(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2)
            {
                _aggregators = aggregators;
            }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, double value) => GetOrAdd(tag1, tag2).Record(value);

            /// <inheritdoc />
            protected override AggregateGauge Create(ImmutableDictionary<string, string> tags) => new AggregateGauge(_aggregators, Name, Unit, Description, Options, tags);
        }
    }
    partial class MetricSource
    {
        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1, TTag2, TTag3}" /> with the specified tags/aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1, TTag2, TTag3> AddAggregateGauge<TTag1, TTag2, TTag3>(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) 
            => Add<AggregateGauge<TTag1, TTag2, TTag3>, AggregateGauge>(new AggregateGauge<TTag1, TTag2, TTag3>(aggregators, name, unit, description, tag1, tag2, tag3, Options));

        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1, TTag2, TTag3}" /> with the specified tags, using <see cref="GaugeAggregator.Default" /> aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1, TTag2, TTag3> AddAggregateGauge<TTag1, TTag2, TTag3>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) 
            => Add<AggregateGauge<TTag1, TTag2, TTag3>, AggregateGauge>(new AggregateGauge<TTag1, TTag2, TTag3>(GaugeAggregator.Default, name, unit, description, tag1, tag2, tag3, Options));

        /// <summary>
        /// Creates a new <see cref="Counter{TTag1, TTag2, TTag3}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual Counter<TTag1, TTag2, TTag3> AddCounter<TTag1, TTag2, TTag3>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) 
            => Add<Counter<TTag1, TTag2, TTag3>, Counter>(new Counter<TTag1, TTag2, TTag3>(name, unit, description, tag1, tag2, tag3, Options));

        /// <summary>
        /// Creates a new <see cref="CumulativeCounter{TTag1, TTag2, TTag3}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual CumulativeCounter<TTag1, TTag2, TTag3> AddCumulativeCounter<TTag1, TTag2, TTag3>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) 
            => Add<CumulativeCounter<TTag1, TTag2, TTag3>, CumulativeCounter>(new CumulativeCounter<TTag1, TTag2, TTag3>(name, unit, description, tag1, tag2, tag3, Options));

        /// <summary>
        /// Creates a new <see cref="EventGauge{TTag1, TTag2, TTag3}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual EventGauge<TTag1, TTag2, TTag3> AddEventGauge<TTag1, TTag2, TTag3>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) 
            => Add<EventGauge<TTag1, TTag2, TTag3>, EventGauge>(new EventGauge<TTag1, TTag2, TTag3>(name, unit, description, tag1, tag2, tag3, Options));

        /// <summary>
        /// Creates a new <see cref="SamplingGauge{TTag1, TTag2, TTag3}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SamplingGauge<TTag1, TTag2, TTag3> AddSamplingGauge<TTag1, TTag2, TTag3>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) 
            => Add<SamplingGauge<TTag1, TTag2, TTag3>, SamplingGauge>(new SamplingGauge<TTag1, TTag2, TTag3>(name, unit, description, tag1, tag2, tag3, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotCounter{TTag1, TTag2, TTag3}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotCounter<TTag1, TTag2, TTag3> AddSnapshotCounter<TTag1, TTag2, TTag3>(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) 
            => Add<SnapshotCounter<TTag1, TTag2, TTag3>, SnapshotCounter>(new SnapshotCounter<TTag1, TTag2, TTag3>(getCountFunc, name, unit, description, tag1, tag2, tag3, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotGauge{TTag1, TTag2, TTag3}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotGauge<TTag1, TTag2, TTag3> AddSnapshotGauge<TTag1, TTag2, TTag3>(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) 
            => Add<SnapshotGauge<TTag1, TTag2, TTag3>, SnapshotGauge>(new SnapshotGauge<TTag1, TTag2, TTag3>(getValueFunc, name, unit, description, tag1, tag2, tag3, Options));
    }
    
    namespace Infrastructure
    {
        /// <summary>
        /// A set of time series which share the same metric name, but have different, strongly-typed tags.
        /// </summary>
        public abstract class TaggedMetricFactory<TMetric, TTag1, TTag2, TTag3> : TaggedMetricFactory<TMetric> where TMetric : MetricBase
        {
            private readonly TaggedMetricDictionary<(TTag1 Tag1, TTag2 Tag2, TTag3 Tag3)> _metrics = new TaggedMetricDictionary<(TTag1 Tag1, TTag2 Tag2, TTag3 Tag3)>();

            /// <summary>
            /// Initializes the base class
            /// </summary>
            protected TaggedMetricFactory(string name, string unit, string description, MetricSourceOptions options, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3) : base(name, unit, description, options)
            {
                Tag1 = TransformAndValidate(tag1);
                Tag2 = TransformAndValidate(tag2);
                Tag3 = TransformAndValidate(tag3);
            }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag1> Tag1 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag2> Tag2 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag3> Tag3 { get; }

            /// <summary>
            /// Gets or adds a new metric for the specific permutation of tag values.
            /// </summary>
            protected TMetric GetOrAdd(TTag1 tag1, TTag2 tag2, TTag3 tag3) => _metrics.GetOrAdd((tag1, tag2, tag3), (key, factory) => factory.Create(key.Tag1, key.Tag2, key.Tag3), this);

            /// <inheritdoc />
            protected override IEnumerable<TMetric> GetMetrics() => _metrics.Values;

            private TMetric Create(TTag1 tag1, TTag2 tag2, TTag3 tag3)
            {
                var tags = ImmutableDictionary.CreateBuilder<string, string>();
                tags[Tag1.Name] = TransformAndValidate(Tag1.Name, tag1);
                tags[Tag2.Name] = TransformAndValidate(Tag2.Name, tag2);
                tags[Tag3.Name] = TransformAndValidate(Tag3.Name, tag3);
                return Create(tags.ToImmutable());
            }
        }
    }

    namespace Metrics
    {
        using StackExchange.Metrics.Handlers;
        using StackExchange.Metrics.Infrastructure;

        /// <summary>
        /// A general-purpose manually incremented long-integer counter.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#counter
        /// </summary>
        public sealed class Counter<TTag1, TTag2, TTag3> : TaggedMetricFactory<Counter, TTag1, TTag2, TTag3>
        {
            internal Counter(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by <paramref name="amount" />.
            /// </summary>
            public void Increment(TTag1 tag1, TTag2 tag2, TTag3 tag3, long amount = 1) => GetOrAdd(tag1, tag2, tag3).Increment(amount);

            /// <inheritdoc />
            protected override Counter Create(ImmutableDictionary<string, string> tags) => new Counter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// A counter that is recorded using the deltas everytime it is incremented . Used for very low-volume events.
        /// </summary>
        /// <remarks>
        /// When using a Bosun endpoint <see cref="BosunMetricHandler.EnableExternalCounters"/> must be true
        /// to be reported. You'll also need to make sure your infrastructure is setup with external counters enabled. This currently requires using tsdbrelay.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#externalcounter
        /// </remarks>
        public sealed class CumulativeCounter<TTag1, TTag2, TTag3> : TaggedMetricFactory<CumulativeCounter, TTag1, TTag2, TTag3>
        {
            internal CumulativeCounter(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by 1.
            /// </summary>
            public void Increment(TTag1 tag1, TTag2 tag2, TTag3 tag3) => GetOrAdd(tag1, tag2, tag3).Increment();

            /// <inheritdoc />
            protected override CumulativeCounter Create(ImmutableDictionary<string, string> tags) => new CumulativeCounter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Every data point results in a <see cref="MetricReading"/>. Good for low-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#eventgauge
        /// </summary>
        public sealed class EventGauge<TTag1, TTag2, TTag3> : TaggedMetricFactory<EventGauge, TTag1, TTag2, TTag3>
        {
            internal EventGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3) { }

            /// <summary>
            /// Records a data point which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, double value) => Record(tag1, tag2, tag3, value, DateTime.UtcNow);

            /// <summary>
            /// Records a data point with an explicit timestamp which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, double value, DateTime time) => GetOrAdd(tag1, tag2, tag3).Record(value, time);

            /// <inheritdoc />
            protected override EventGauge Create(ImmutableDictionary<string, string> tags) => new EventGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Record as often as you want, but only the last value recorded before the reporting interval is sent to an endpoint (it samples the current value).
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#samplinggauge
        /// </summary>
        public sealed class SamplingGauge<TTag1, TTag2, TTag3> : TaggedMetricFactory<SamplingGauge, TTag1, TTag2, TTag3>
        {
            internal SamplingGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3) { }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, double value) => GetOrAdd(tag1, tag2, tag3).Record(value);

            /// <inheritdoc />
            protected override SamplingGauge Create(ImmutableDictionary<string, string> tags) => new SamplingGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Calls a user-provided Func&lt;long?&gt; to get the current counter value each time metrics are going to be posted to a metrics handler.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotcounter
        /// </summary>
        public sealed class SnapshotCounter<TTag1, TTag2, TTag3> : TaggedMetricFactory<SnapshotCounter, TTag1, TTag2, TTag3>
        {
            private readonly Func<long?> _getCountFunc;

            internal SnapshotCounter(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3)
            {
                if (getCountFunc == null)
                {
                    throw new ArgumentNullException(nameof(getCountFunc));
                }

                _getCountFunc = getCountFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotCounter" /> for the specified tags.
            /// </summary>
            public SnapshotCounter Get(TTag1 tag1, TTag2 tag2, TTag3 tag3) => GetOrAdd(tag1, tag2, tag3);

            /// <inheritdoc />
            protected override SnapshotCounter Create(ImmutableDictionary<string, string> tags) => new SnapshotCounter(_getCountFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Similar to a SnapshotCounter, it calls a user provided Func&lt;double?&gt; to get the current gauge value each time metrics are going to be posted to
        /// a metrics handler. See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotgauge
        /// </summary>
        public sealed class SnapshotGauge<TTag1, TTag2, TTag3> : TaggedMetricFactory<SnapshotGauge, TTag1, TTag2, TTag3>
        {
            private readonly Func<double?> _getValueFunc;

            internal SnapshotGauge(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3)
            {
                if (getValueFunc == null)
                {
                    throw new ArgumentNullException(nameof(getValueFunc));
                }

                _getValueFunc = getValueFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotGauge" /> for the specified tags.
            /// </summary>
            public SnapshotGauge Get(TTag1 tag1, TTag2 tag2, TTag3 tag3) => GetOrAdd(tag1, tag2, tag3);

            /// <inheritdoc />
            protected override SnapshotGauge Create(ImmutableDictionary<string, string> tags) => new SnapshotGauge(_getValueFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Aggregates data points (min, max, avg, median, etc) before sending them to a handler. Good for recording high-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#aggregategauge
        /// </summary>
        public sealed class AggregateGauge<TTag1, TTag2, TTag3> : TaggedMetricFactory<AggregateGauge, TTag1, TTag2, TTag3>
        {
            private readonly IEnumerable<GaugeAggregator> _aggregators;

            internal AggregateGauge(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3)
            {
                _aggregators = aggregators;
            }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, double value) => GetOrAdd(tag1, tag2, tag3).Record(value);

            /// <inheritdoc />
            protected override AggregateGauge Create(ImmutableDictionary<string, string> tags) => new AggregateGauge(_aggregators, Name, Unit, Description, Options, tags);
        }
    }
    partial class MetricSource
    {
        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1, TTag2, TTag3, TTag4}" /> with the specified tags/aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1, TTag2, TTag3, TTag4> AddAggregateGauge<TTag1, TTag2, TTag3, TTag4>(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) 
            => Add<AggregateGauge<TTag1, TTag2, TTag3, TTag4>, AggregateGauge>(new AggregateGauge<TTag1, TTag2, TTag3, TTag4>(aggregators, name, unit, description, tag1, tag2, tag3, tag4, Options));

        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1, TTag2, TTag3, TTag4}" /> with the specified tags, using <see cref="GaugeAggregator.Default" /> aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1, TTag2, TTag3, TTag4> AddAggregateGauge<TTag1, TTag2, TTag3, TTag4>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) 
            => Add<AggregateGauge<TTag1, TTag2, TTag3, TTag4>, AggregateGauge>(new AggregateGauge<TTag1, TTag2, TTag3, TTag4>(GaugeAggregator.Default, name, unit, description, tag1, tag2, tag3, tag4, Options));

        /// <summary>
        /// Creates a new <see cref="Counter{TTag1, TTag2, TTag3, TTag4}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual Counter<TTag1, TTag2, TTag3, TTag4> AddCounter<TTag1, TTag2, TTag3, TTag4>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) 
            => Add<Counter<TTag1, TTag2, TTag3, TTag4>, Counter>(new Counter<TTag1, TTag2, TTag3, TTag4>(name, unit, description, tag1, tag2, tag3, tag4, Options));

        /// <summary>
        /// Creates a new <see cref="CumulativeCounter{TTag1, TTag2, TTag3, TTag4}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual CumulativeCounter<TTag1, TTag2, TTag3, TTag4> AddCumulativeCounter<TTag1, TTag2, TTag3, TTag4>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) 
            => Add<CumulativeCounter<TTag1, TTag2, TTag3, TTag4>, CumulativeCounter>(new CumulativeCounter<TTag1, TTag2, TTag3, TTag4>(name, unit, description, tag1, tag2, tag3, tag4, Options));

        /// <summary>
        /// Creates a new <see cref="EventGauge{TTag1, TTag2, TTag3, TTag4}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual EventGauge<TTag1, TTag2, TTag3, TTag4> AddEventGauge<TTag1, TTag2, TTag3, TTag4>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) 
            => Add<EventGauge<TTag1, TTag2, TTag3, TTag4>, EventGauge>(new EventGauge<TTag1, TTag2, TTag3, TTag4>(name, unit, description, tag1, tag2, tag3, tag4, Options));

        /// <summary>
        /// Creates a new <see cref="SamplingGauge{TTag1, TTag2, TTag3, TTag4}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SamplingGauge<TTag1, TTag2, TTag3, TTag4> AddSamplingGauge<TTag1, TTag2, TTag3, TTag4>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) 
            => Add<SamplingGauge<TTag1, TTag2, TTag3, TTag4>, SamplingGauge>(new SamplingGauge<TTag1, TTag2, TTag3, TTag4>(name, unit, description, tag1, tag2, tag3, tag4, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotCounter{TTag1, TTag2, TTag3, TTag4}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotCounter<TTag1, TTag2, TTag3, TTag4> AddSnapshotCounter<TTag1, TTag2, TTag3, TTag4>(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) 
            => Add<SnapshotCounter<TTag1, TTag2, TTag3, TTag4>, SnapshotCounter>(new SnapshotCounter<TTag1, TTag2, TTag3, TTag4>(getCountFunc, name, unit, description, tag1, tag2, tag3, tag4, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotGauge{TTag1, TTag2, TTag3, TTag4}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotGauge<TTag1, TTag2, TTag3, TTag4> AddSnapshotGauge<TTag1, TTag2, TTag3, TTag4>(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) 
            => Add<SnapshotGauge<TTag1, TTag2, TTag3, TTag4>, SnapshotGauge>(new SnapshotGauge<TTag1, TTag2, TTag3, TTag4>(getValueFunc, name, unit, description, tag1, tag2, tag3, tag4, Options));
    }
    
    namespace Infrastructure
    {
        /// <summary>
        /// A set of time series which share the same metric name, but have different, strongly-typed tags.
        /// </summary>
        public abstract class TaggedMetricFactory<TMetric, TTag1, TTag2, TTag3, TTag4> : TaggedMetricFactory<TMetric> where TMetric : MetricBase
        {
            private readonly TaggedMetricDictionary<(TTag1 Tag1, TTag2 Tag2, TTag3 Tag3, TTag4 Tag4)> _metrics = new TaggedMetricDictionary<(TTag1 Tag1, TTag2 Tag2, TTag3 Tag3, TTag4 Tag4)>();

            /// <summary>
            /// Initializes the base class
            /// </summary>
            protected TaggedMetricFactory(string name, string unit, string description, MetricSourceOptions options, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4) : base(name, unit, description, options)
            {
                Tag1 = TransformAndValidate(tag1);
                Tag2 = TransformAndValidate(tag2);
                Tag3 = TransformAndValidate(tag3);
                Tag4 = TransformAndValidate(tag4);
            }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag1> Tag1 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag2> Tag2 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag3> Tag3 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag4> Tag4 { get; }

            /// <summary>
            /// Gets or adds a new metric for the specific permutation of tag values.
            /// </summary>
            protected TMetric GetOrAdd(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4) => _metrics.GetOrAdd((tag1, tag2, tag3, tag4), (key, factory) => factory.Create(key.Tag1, key.Tag2, key.Tag3, key.Tag4), this);

            /// <inheritdoc />
            protected override IEnumerable<TMetric> GetMetrics() => _metrics.Values;

            private TMetric Create(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4)
            {
                var tags = ImmutableDictionary.CreateBuilder<string, string>();
                tags[Tag1.Name] = TransformAndValidate(Tag1.Name, tag1);
                tags[Tag2.Name] = TransformAndValidate(Tag2.Name, tag2);
                tags[Tag3.Name] = TransformAndValidate(Tag3.Name, tag3);
                tags[Tag4.Name] = TransformAndValidate(Tag4.Name, tag4);
                return Create(tags.ToImmutable());
            }
        }
    }

    namespace Metrics
    {
        using StackExchange.Metrics.Handlers;
        using StackExchange.Metrics.Infrastructure;

        /// <summary>
        /// A general-purpose manually incremented long-integer counter.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#counter
        /// </summary>
        public sealed class Counter<TTag1, TTag2, TTag3, TTag4> : TaggedMetricFactory<Counter, TTag1, TTag2, TTag3, TTag4>
        {
            internal Counter(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by <paramref name="amount" />.
            /// </summary>
            public void Increment(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, long amount = 1) => GetOrAdd(tag1, tag2, tag3, tag4).Increment(amount);

            /// <inheritdoc />
            protected override Counter Create(ImmutableDictionary<string, string> tags) => new Counter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// A counter that is recorded using the deltas everytime it is incremented . Used for very low-volume events.
        /// </summary>
        /// <remarks>
        /// When using a Bosun endpoint <see cref="BosunMetricHandler.EnableExternalCounters"/> must be true
        /// to be reported. You'll also need to make sure your infrastructure is setup with external counters enabled. This currently requires using tsdbrelay.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#externalcounter
        /// </remarks>
        public sealed class CumulativeCounter<TTag1, TTag2, TTag3, TTag4> : TaggedMetricFactory<CumulativeCounter, TTag1, TTag2, TTag3, TTag4>
        {
            internal CumulativeCounter(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by 1.
            /// </summary>
            public void Increment(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4) => GetOrAdd(tag1, tag2, tag3, tag4).Increment();

            /// <inheritdoc />
            protected override CumulativeCounter Create(ImmutableDictionary<string, string> tags) => new CumulativeCounter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Every data point results in a <see cref="MetricReading"/>. Good for low-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#eventgauge
        /// </summary>
        public sealed class EventGauge<TTag1, TTag2, TTag3, TTag4> : TaggedMetricFactory<EventGauge, TTag1, TTag2, TTag3, TTag4>
        {
            internal EventGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4) { }

            /// <summary>
            /// Records a data point which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, double value) => Record(tag1, tag2, tag3, tag4, value, DateTime.UtcNow);

            /// <summary>
            /// Records a data point with an explicit timestamp which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, double value, DateTime time) => GetOrAdd(tag1, tag2, tag3, tag4).Record(value, time);

            /// <inheritdoc />
            protected override EventGauge Create(ImmutableDictionary<string, string> tags) => new EventGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Record as often as you want, but only the last value recorded before the reporting interval is sent to an endpoint (it samples the current value).
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#samplinggauge
        /// </summary>
        public sealed class SamplingGauge<TTag1, TTag2, TTag3, TTag4> : TaggedMetricFactory<SamplingGauge, TTag1, TTag2, TTag3, TTag4>
        {
            internal SamplingGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4) { }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, double value) => GetOrAdd(tag1, tag2, tag3, tag4).Record(value);

            /// <inheritdoc />
            protected override SamplingGauge Create(ImmutableDictionary<string, string> tags) => new SamplingGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Calls a user-provided Func&lt;long?&gt; to get the current counter value each time metrics are going to be posted to a metrics handler.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotcounter
        /// </summary>
        public sealed class SnapshotCounter<TTag1, TTag2, TTag3, TTag4> : TaggedMetricFactory<SnapshotCounter, TTag1, TTag2, TTag3, TTag4>
        {
            private readonly Func<long?> _getCountFunc;

            internal SnapshotCounter(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4)
            {
                if (getCountFunc == null)
                {
                    throw new ArgumentNullException(nameof(getCountFunc));
                }

                _getCountFunc = getCountFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotCounter" /> for the specified tags.
            /// </summary>
            public SnapshotCounter Get(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4) => GetOrAdd(tag1, tag2, tag3, tag4);

            /// <inheritdoc />
            protected override SnapshotCounter Create(ImmutableDictionary<string, string> tags) => new SnapshotCounter(_getCountFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Similar to a SnapshotCounter, it calls a user provided Func&lt;double?&gt; to get the current gauge value each time metrics are going to be posted to
        /// a metrics handler. See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotgauge
        /// </summary>
        public sealed class SnapshotGauge<TTag1, TTag2, TTag3, TTag4> : TaggedMetricFactory<SnapshotGauge, TTag1, TTag2, TTag3, TTag4>
        {
            private readonly Func<double?> _getValueFunc;

            internal SnapshotGauge(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4)
            {
                if (getValueFunc == null)
                {
                    throw new ArgumentNullException(nameof(getValueFunc));
                }

                _getValueFunc = getValueFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotGauge" /> for the specified tags.
            /// </summary>
            public SnapshotGauge Get(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4) => GetOrAdd(tag1, tag2, tag3, tag4);

            /// <inheritdoc />
            protected override SnapshotGauge Create(ImmutableDictionary<string, string> tags) => new SnapshotGauge(_getValueFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Aggregates data points (min, max, avg, median, etc) before sending them to a handler. Good for recording high-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#aggregategauge
        /// </summary>
        public sealed class AggregateGauge<TTag1, TTag2, TTag3, TTag4> : TaggedMetricFactory<AggregateGauge, TTag1, TTag2, TTag3, TTag4>
        {
            private readonly IEnumerable<GaugeAggregator> _aggregators;

            internal AggregateGauge(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4)
            {
                _aggregators = aggregators;
            }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, double value) => GetOrAdd(tag1, tag2, tag3, tag4).Record(value);

            /// <inheritdoc />
            protected override AggregateGauge Create(ImmutableDictionary<string, string> tags) => new AggregateGauge(_aggregators, Name, Unit, Description, Options, tags);
        }
    }
    partial class MetricSource
    {
        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1, TTag2, TTag3, TTag4, TTag5}" /> with the specified tags/aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5> AddAggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) 
            => Add<AggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5>, AggregateGauge>(new AggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(aggregators, name, unit, description, tag1, tag2, tag3, tag4, tag5, Options));

        /// <summary>
        /// Creates a new <see cref="AggregateGauge{TTag1, TTag2, TTag3, TTag4, TTag5}" /> with the specified tags, using <see cref="GaugeAggregator.Default" /> aggregators and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual AggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5> AddAggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) 
            => Add<AggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5>, AggregateGauge>(new AggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(GaugeAggregator.Default, name, unit, description, tag1, tag2, tag3, tag4, tag5, Options));

        /// <summary>
        /// Creates a new <see cref="Counter{TTag1, TTag2, TTag3, TTag4, TTag5}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual Counter<TTag1, TTag2, TTag3, TTag4, TTag5> AddCounter<TTag1, TTag2, TTag3, TTag4, TTag5>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) 
            => Add<Counter<TTag1, TTag2, TTag3, TTag4, TTag5>, Counter>(new Counter<TTag1, TTag2, TTag3, TTag4, TTag5>(name, unit, description, tag1, tag2, tag3, tag4, tag5, Options));

        /// <summary>
        /// Creates a new <see cref="CumulativeCounter{TTag1, TTag2, TTag3, TTag4, TTag5}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual CumulativeCounter<TTag1, TTag2, TTag3, TTag4, TTag5> AddCumulativeCounter<TTag1, TTag2, TTag3, TTag4, TTag5>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) 
            => Add<CumulativeCounter<TTag1, TTag2, TTag3, TTag4, TTag5>, CumulativeCounter>(new CumulativeCounter<TTag1, TTag2, TTag3, TTag4, TTag5>(name, unit, description, tag1, tag2, tag3, tag4, tag5, Options));

        /// <summary>
        /// Creates a new <see cref="EventGauge{TTag1, TTag2, TTag3, TTag4, TTag5}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual EventGauge<TTag1, TTag2, TTag3, TTag4, TTag5> AddEventGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) 
            => Add<EventGauge<TTag1, TTag2, TTag3, TTag4, TTag5>, EventGauge>(new EventGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(name, unit, description, tag1, tag2, tag3, tag4, tag5, Options));

        /// <summary>
        /// Creates a new <see cref="SamplingGauge{TTag1, TTag2, TTag3, TTag4, TTag5}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SamplingGauge<TTag1, TTag2, TTag3, TTag4, TTag5> AddSamplingGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) 
            => Add<SamplingGauge<TTag1, TTag2, TTag3, TTag4, TTag5>, SamplingGauge>(new SamplingGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(name, unit, description, tag1, tag2, tag3, tag4, tag5, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotCounter{TTag1, TTag2, TTag3, TTag4, TTag5}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotCounter<TTag1, TTag2, TTag3, TTag4, TTag5> AddSnapshotCounter<TTag1, TTag2, TTag3, TTag4, TTag5>(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) 
            => Add<SnapshotCounter<TTag1, TTag2, TTag3, TTag4, TTag5>, SnapshotCounter>(new SnapshotCounter<TTag1, TTag2, TTag3, TTag4, TTag5>(getCountFunc, name, unit, description, tag1, tag2, tag3, tag4, tag5, Options));

        /// <summary>
        /// Creates a new <see cref="SnapshotGauge{TTag1, TTag2, TTag3, TTag4, TTag5}" /> with the specified tags and adds it to the <see cref="MetricSource" />.
        /// </summary>
        public virtual SnapshotGauge<TTag1, TTag2, TTag3, TTag4, TTag5> AddSnapshotGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) 
            => Add<SnapshotGauge<TTag1, TTag2, TTag3, TTag4, TTag5>, SnapshotGauge>(new SnapshotGauge<TTag1, TTag2, TTag3, TTag4, TTag5>(getValueFunc, name, unit, description, tag1, tag2, tag3, tag4, tag5, Options));
    }
    
    namespace Infrastructure
    {
        /// <summary>
        /// A set of time series which share the same metric name, but have different, strongly-typed tags.
        /// </summary>
        public abstract class TaggedMetricFactory<TMetric, TTag1, TTag2, TTag3, TTag4, TTag5> : TaggedMetricFactory<TMetric> where TMetric : MetricBase
        {
            private readonly TaggedMetricDictionary<(TTag1 Tag1, TTag2 Tag2, TTag3 Tag3, TTag4 Tag4, TTag5 Tag5)> _metrics = new TaggedMetricDictionary<(TTag1 Tag1, TTag2 Tag2, TTag3 Tag3, TTag4 Tag4, TTag5 Tag5)>();

            /// <summary>
            /// Initializes the base class
            /// </summary>
            protected TaggedMetricFactory(string name, string unit, string description, MetricSourceOptions options, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5) : base(name, unit, description, options)
            {
                Tag1 = TransformAndValidate(tag1);
                Tag2 = TransformAndValidate(tag2);
                Tag3 = TransformAndValidate(tag3);
                Tag4 = TransformAndValidate(tag4);
                Tag5 = TransformAndValidate(tag5);
            }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag1> Tag1 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag2> Tag2 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag3> Tag3 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag4> Tag4 { get; }

            /// <summary>
            /// Gets metadata for the tag.
            /// </summary>
            public MetricTag<TTag5> Tag5 { get; }

            /// <summary>
            /// Gets or adds a new metric for the specific permutation of tag values.
            /// </summary>
            protected TMetric GetOrAdd(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5) => _metrics.GetOrAdd((tag1, tag2, tag3, tag4, tag5), (key, factory) => factory.Create(key.Tag1, key.Tag2, key.Tag3, key.Tag4, key.Tag5), this);

            /// <inheritdoc />
            protected override IEnumerable<TMetric> GetMetrics() => _metrics.Values;

            private TMetric Create(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5)
            {
                var tags = ImmutableDictionary.CreateBuilder<string, string>();
                tags[Tag1.Name] = TransformAndValidate(Tag1.Name, tag1);
                tags[Tag2.Name] = TransformAndValidate(Tag2.Name, tag2);
                tags[Tag3.Name] = TransformAndValidate(Tag3.Name, tag3);
                tags[Tag4.Name] = TransformAndValidate(Tag4.Name, tag4);
                tags[Tag5.Name] = TransformAndValidate(Tag5.Name, tag5);
                return Create(tags.ToImmutable());
            }
        }
    }

    namespace Metrics
    {
        using StackExchange.Metrics.Handlers;
        using StackExchange.Metrics.Infrastructure;

        /// <summary>
        /// A general-purpose manually incremented long-integer counter.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#counter
        /// </summary>
        public sealed class Counter<TTag1, TTag2, TTag3, TTag4, TTag5> : TaggedMetricFactory<Counter, TTag1, TTag2, TTag3, TTag4, TTag5>
        {
            internal Counter(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4, tag5) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by <paramref name="amount" />.
            /// </summary>
            public void Increment(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5, long amount = 1) => GetOrAdd(tag1, tag2, tag3, tag4, tag5).Increment(amount);

            /// <inheritdoc />
            protected override Counter Create(ImmutableDictionary<string, string> tags) => new Counter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// A counter that is recorded using the deltas everytime it is incremented . Used for very low-volume events.
        /// </summary>
        /// <remarks>
        /// When using a Bosun endpoint <see cref="BosunMetricHandler.EnableExternalCounters"/> must be true
        /// to be reported. You'll also need to make sure your infrastructure is setup with external counters enabled. This currently requires using tsdbrelay.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#externalcounter
        /// </remarks>
        public sealed class CumulativeCounter<TTag1, TTag2, TTag3, TTag4, TTag5> : TaggedMetricFactory<CumulativeCounter, TTag1, TTag2, TTag3, TTag4, TTag5>
        {
            internal CumulativeCounter(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4, tag5) { }

            /// <summary>
            /// Increments the counter with the specified permutation of tags by 1.
            /// </summary>
            public void Increment(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5) => GetOrAdd(tag1, tag2, tag3, tag4, tag5).Increment();

            /// <inheritdoc />
            protected override CumulativeCounter Create(ImmutableDictionary<string, string> tags) => new CumulativeCounter(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Every data point results in a <see cref="MetricReading"/>. Good for low-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#eventgauge
        /// </summary>
        public sealed class EventGauge<TTag1, TTag2, TTag3, TTag4, TTag5> : TaggedMetricFactory<EventGauge, TTag1, TTag2, TTag3, TTag4, TTag5>
        {
            internal EventGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4, tag5) { }

            /// <summary>
            /// Records a data point which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5, double value) => Record(tag1, tag2, tag3, tag4, tag5, value, DateTime.UtcNow);

            /// <summary>
            /// Records a data point with an explicit timestamp which will be sent to metrics handlers.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5, double value, DateTime time) => GetOrAdd(tag1, tag2, tag3, tag4, tag5).Record(value, time);

            /// <inheritdoc />
            protected override EventGauge Create(ImmutableDictionary<string, string> tags) => new EventGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Record as often as you want, but only the last value recorded before the reporting interval is sent to an endpoint (it samples the current value).
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#samplinggauge
        /// </summary>
        public sealed class SamplingGauge<TTag1, TTag2, TTag3, TTag4, TTag5> : TaggedMetricFactory<SamplingGauge, TTag1, TTag2, TTag3, TTag4, TTag5>
        {
            internal SamplingGauge(string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4, tag5) { }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5, double value) => GetOrAdd(tag1, tag2, tag3, tag4, tag5).Record(value);

            /// <inheritdoc />
            protected override SamplingGauge Create(ImmutableDictionary<string, string> tags) => new SamplingGauge(Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Calls a user-provided Func&lt;long?&gt; to get the current counter value each time metrics are going to be posted to a metrics handler.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotcounter
        /// </summary>
        public sealed class SnapshotCounter<TTag1, TTag2, TTag3, TTag4, TTag5> : TaggedMetricFactory<SnapshotCounter, TTag1, TTag2, TTag3, TTag4, TTag5>
        {
            private readonly Func<long?> _getCountFunc;

            internal SnapshotCounter(Func<long?> getCountFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4, tag5)
            {
                if (getCountFunc == null)
                {
                    throw new ArgumentNullException(nameof(getCountFunc));
                }

                _getCountFunc = getCountFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotCounter" /> for the specified tags.
            /// </summary>
            public SnapshotCounter Get(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5) => GetOrAdd(tag1, tag2, tag3, tag4, tag5);

            /// <inheritdoc />
            protected override SnapshotCounter Create(ImmutableDictionary<string, string> tags) => new SnapshotCounter(_getCountFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Similar to a SnapshotCounter, it calls a user provided Func&lt;double?&gt; to get the current gauge value each time metrics are going to be posted to
        /// a metrics handler. See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#snapshotgauge
        /// </summary>
        public sealed class SnapshotGauge<TTag1, TTag2, TTag3, TTag4, TTag5> : TaggedMetricFactory<SnapshotGauge, TTag1, TTag2, TTag3, TTag4, TTag5>
        {
            private readonly Func<double?> _getValueFunc;

            internal SnapshotGauge(Func<double?> getValueFunc, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4, tag5)
            {
                if (getValueFunc == null)
                {
                    throw new ArgumentNullException(nameof(getValueFunc));
                }

                _getValueFunc = getValueFunc;
            }

            /// <summary>
            /// Gets the <see cref="SnapshotGauge" /> for the specified tags.
            /// </summary>
            public SnapshotGauge Get(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5) => GetOrAdd(tag1, tag2, tag3, tag4, tag5);

            /// <inheritdoc />
            protected override SnapshotGauge Create(ImmutableDictionary<string, string> tags) => new SnapshotGauge(_getValueFunc, Name, Unit, Description, Options, tags);
        }

        /// <summary>
        /// Aggregates data points (min, max, avg, median, etc) before sending them to a handler. Good for recording high-volume events.
        /// See https://github.com/StackExchange/StackExchange.Metrics/blob/master/docs/MetricTypes.md#aggregategauge
        /// </summary>
        public sealed class AggregateGauge<TTag1, TTag2, TTag3, TTag4, TTag5> : TaggedMetricFactory<AggregateGauge, TTag1, TTag2, TTag3, TTag4, TTag5>
        {
            private readonly IEnumerable<GaugeAggregator> _aggregators;

            internal AggregateGauge(IEnumerable<GaugeAggregator> aggregators, string name, string unit, string description, in MetricTag<TTag1> tag1, in MetricTag<TTag2> tag2, in MetricTag<TTag3> tag3, in MetricTag<TTag4> tag4, in MetricTag<TTag5> tag5, MetricSourceOptions options) : base(name, unit, description, options, tag1, tag2, tag3, tag4, tag5)
            {
                _aggregators = aggregators;
            }

            /// <summary>
            /// Records the current value of the gauge. Use Double.NaN to disable this gauge.
            /// </summary>
            public void Record(TTag1 tag1, TTag2 tag2, TTag3 tag3, TTag4 tag4, TTag5 tag5, double value) => GetOrAdd(tag1, tag2, tag3, tag4, tag5).Record(value);

            /// <inheritdoc />
            protected override AggregateGauge Create(ImmutableDictionary<string, string> tags) => new AggregateGauge(_aggregators, Name, Unit, Description, Options, tags);
        }
    }
}